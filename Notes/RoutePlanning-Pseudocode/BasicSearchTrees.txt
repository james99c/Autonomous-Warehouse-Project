routeForAllRobots(){
  # organise robotList by shortest heuristicCost
  ArrayList<ArrayList<Location>> allRoutes;
  for robot in robotList{
      ArrayList<locations> route;
      new SearchTree(robot.location, robot.location, 0, robot.goalLocation, Empty, new ArrayList<Location>(), route).search();
      allRoutes.add(route);
      virtualMap.remove(route);
  }
  return allRoute;
}


SearchTree{
  childNodes;
  static usableLeafNodes;

  // currentPath contains locations with Time frames
  SearchTree(currentLocation, previousLocation, currentCost, goalLocation, currentPath, inputVariable){
    this.currentLocation = currentLocation;
    this.previousLocation = previousLocation;
    this.currentCost = currentCost;
    this.goalLocation = goalLocation;
    this.currentPath = currentPath;
    this.inputVariable = inputVariable;
    this.heuristicCost = virtualMap.getHeuristicCost(CurrentLocation, goalLocation);
    this.totalCost = cost + heuristicCost;
  }

  searchForGoal(){
    if(! atGoalLocation){
      NewLocationList = virtualMap.findAllMovementOptions(currentLocation);
      if(NewLocationList.size() == 0){
        try{
          usableLeafNodes.get(0).remove().search();
          return;
        } catch(index out of range){
          usableLeafNodes.empty();
          throw("there is no possible path to the goalNode");
          return;
        }
      }
      else{
        for (i in NewLocationList){                                                                                                   // need to have time frame and currentCost
          this.childNodes.add(new Node(NewLocationList.get(i), this.currentLocation, currentCost + 1, this.goalLocation, this, currentPath.add(NewLocationList.get(i), currentCost), this.inputVariable, this.usableLeafNodes));
        }
        then sort child nodes from lowest to highest totalCost

          usableLeafNodes.add(childNodes);
          #Sort usable Leaf nodes from lowest total cost to highest total cost
          usableLeafNodes.remove();
          return;

      }
    }
    else{  // at goal location
      if(usableLeafNodes.get(0) => currentCost){
        this.inputVariable = currentPath;
        this.usableLeafNodes.empty();
        return;
      }
      else{
        usableLeafNodes.get(0).remove().search();
        return;
      }
    }
  }
}
